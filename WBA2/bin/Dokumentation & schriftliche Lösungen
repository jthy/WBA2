Phase 1:

Aufgabe1 - Erklären Sie kurz die Begriffe Wohlgeformtheit, Validität und Namespaces im Bezug auf XML und XML-Schema.
Namespace:
Namen für Objekte werden in einer Art Baumstruktur angeordnet und über entsprechende Pfadnamen eindeutig angesprochen.

Wohlgeformtheit:
Wenn XML Dokument alle XML-Regeln einhält

Validität:
Das argumentative Gewicht einer Aussage, Untersuchung oder Theorie

Aufgabe2 
a) Erzeugen Sie ein XML-Dokument, dass die Daten des folgenden Formulars vollständig erfasst:

Die Xml-Datei (Augabe20.xml) besteht aus einem Element "Gruppe" welches aus einem Gruppenleiter und einer oder mehreren anderen Personen besteht.
Diese Mitglieder der Gruppe werden durch die selben Eigenschaften beschrieben werden. 
Am Ende werden den AGB zugestimmt und die Gruppe ist vollständig.

b) Erzeugen Sie ein JSON-Dokument, dass zu ihrem XML-Dokument äquivalent ist.
Das Json-Dokument war schwiergiger zu erstellen. Jedoch lag dies nicht an JSON an sich, sondern an der eigentlichen Erstellung der Datei.
Im jetzigen Zustand endet die Datei auf .xml, obwohl sie eigentlich auf .json enden sollte. Nach einigen Versuchen wurde die Aufgabe im JSON-Editor erstellt.

Aufgabe3
a)Entwickeln Sie ein XML-Dokument, in dem die Daten des Rezeptes abgebildet werden. Achten Sie darauf, dass das Dokument semantisch möglichst reichhaltig ist. 
Bei dieser und den folgenden Aufgaben lassen sie bitte die Daten in der Marginalspalte auf der rechten Seite weg.

Das XML-Dokuement besteht aus einem Root-Element "Rezept", welches die Elemente "Allgemeines", "Zutaten", "Zubereitung" und "KommentareandererNutzer" beinhaltet.
Die verschiedenen Zutaten werden nacheinander aufgelistet und durch verschiedene Eigenschaften definiert(Gewicht, Einheit, Name). 
Die einzelnen Schritte der Zubereitung werden durch ein Element aufgeschrieben und nicht, wie in einer früheren Version als einzelne Elemente.
Dies erschien im Nachhinein unsinnig. Buttons werden nicht mit im XML-Dokument aufgelistet, da diese keine Information einlesen.
Auch Bilder werden in der Datei nicht mit eingefügt.

b) Betrachten Sie nun andere Rezepte auf der Webseite http://www.chefkoch.de. Beschreiben Sie welche Gemeinsamkeiten die Rezepte hinsichtlich ihrer Daten haben und worin Sie sich unterscheiden.

Gemeinsamkeiten:
Design(Aufbau, Buttons, Bilder-Slideshow, Schriftgröße, Farben), Möglichkeit zu Kommentieren
Es gibt einen Titel, Zutatenangaben(Gewicht, Einheit und Name), Zubereitung(Arbeitszeit, Schwierigeitsgrad, Brennwert, Schritte)


Unterschiede:
Bilderinhalte, Texte, Zutaten, Anzahl der Kommentare, Anzahl der Schritte

c) Arbeiten Sie die Kriterien heraus, die für die Entwicklung einer XML-Schema-Datei beachtet werden müssen. Die Schema-Datei soll die Struktur für eine XML-Datei definieren, in der mehrere unterschiedliche Rezepte gespeichert werden können. 
Ziel ist es, dass das XML-Schema möglichst restriktiv ist, so dass in der XML-Datei möglichst semantisch sinnvolle Daten bezüglich der Rezepte gespeichert werden können. Ziehen Sie beim Aufstellen der Kriterien u.A. folgende Fragestellungen in Betracht:

Welche Daten müssen in simple und welche in complex-types abgebildet werden?
Für welche Daten ist die Abbildung in Attributen sinnvoller?
Welche Datentypen müssen für die Elemente definiert werden?
Welche Restriktionen müssen definiert werden?

Kriterien:
-Datei wird durch "Allgemeines", "Zutaten", "Portionen", "Zubereitung" und "Kommentieren" bestimmt
-Restrictions: Portionen, Schwierigkeitsgrad, Kommentar hilfreich?, 
-Komplex:Rezept(als Root-Element) Allgemeines, Zutaten, Zubereitung, Kommentieren
-Simpel: Rezeptname, Autor, Zutat, Gewicht, Einheit, Restrictions(Portionen,Kommentar_hilfreich),Arbeitszeit, Schwierigkeitsgrad, Brennwert p.P, Vorgänge, Name beim Kommentieren, Datum beim Kommentieren, Zeit beim Kommentieren, Kommentare, Attribute (Kommentar_hilfreich)

d) Erstellen Sie nun ein XML-Schema auf Basis ihrer zuvor definierten Kriterien. Generieren Sie nun auf Basis des Schemas eine XML-Datei und füllen Sie diese mit zwei unterschiedlichen und validen Datensätzen.
Es werden die Daten für einen Schokoladenkuchen und Pilav eingefügt.

Aufgabe4:

a) Erzeugen Sie zunächst aus der Schema-Datei der vorherigen Aufgabe Java-Objekte

Es werden Rezept.java,.ava Chefkoch und ObjectFactory.java generiert. Gleichzeitig werden die Daten auf github hochgeladen.
Die Lösung der Aufgabe gestaltet sich als die schwierigste der ganzen Phase. Nach einigem hin und her gibt es innnerhalb der Datei Aufgabe4b.java keine Fehlermeldung.
Beim Ausführen der Datei gibt es jedoch folgende Fehlermeldung:
Exception in thread "main" javax.xml.bind.UnmarshalException
 - with linked exception:
[org.xml.sax.SAXParseException: Element type "Vorg" must be followed by either attribute specifications, ">" or "/>".]
	at javax.xml.bind.helpers.AbstractUnmarshallerImpl.createUnmarshalException(AbstractUnmarshallerImpl.java:315)
	at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.createUnmarshalException(UnmarshallerImpl.java:527)
	at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal0(UnmarshallerImpl.java:224)
	at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal(UnmarshallerImpl.java:190)
	at javax.xml.bind.helpers.AbstractUnmarshallerImpl.unmarshal(AbstractUnmarshallerImpl.java:137)
	at javax.xml.bind.helpers.AbstractUnmarshallerImpl.unmarshal(AbstractUnmarshallerImpl.java:194)
	at generated.Aufgabe4b.main(Aufgabe4b.java:121)
Caused by: org.xml.sax.SAXParseException: Element type "Vorg" must be followed by either attribute specifications, ">" or "/>".
	at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java:195)
	at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.fatalError(ErrorHandlerWrapper.java:174)
	at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:388)
	at com.sun.org.apache.xerces.internal.impl.XMLScanner.reportFatalError(XMLScanner.java:1427)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.seekCloseOfStartTag(XMLDocumentFragmentScannerImpl.java:1395)
	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:269)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2756)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:647)
	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(XMLNSDocumentScannerImpl.java:140)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737)
	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205)
	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522)
	at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal0(UnmarshallerImpl.java:218)
	... 4 more

Es stellt sich heraus, dass die Aufgabe zunächst falsch gelöst wurde, da eine neue XML-Datei erstellt und eingelesen wurde statt, wie in der Aufgabe
gefordert, aus der bestehenden XML Daten herauszulesen.
Die Datei wird angepasst und zum Teil neugeschrieben.
Die Daten werden nun statt mit der set-Methode mit der get-Methode eingelesen.

Ein Problem ergibt sich aus der Auflistung der Zutaten, da zunächst nur eine Zutat ausgegeben wird. 
Das Problem kann durch eine Schleife gelöst werden.

b) Es wird die neue Methode eingeben erstellt.
Über die Tastatur kann das Rezept eingegeben werden, zu dem der Kommentar erstellt werden soll.
Ist dies ausgewählt, können Name und Kommentar eingegeben werden. Die Systemzeit wird automaitsich ermittelt.
Ist das ausgewählte Rezept nicht vorhanden, wird eine Fehlermeldung ausgegeben.
Die Kommentare werden dann der XML-Datei hinzugefügt.

Das Programm zeigt keine Fehler an, jedoch kommt es bei der Ausführung zu folgender Fehlermeldung:

Das Element chefkoch befindet sich jedoch nach einigen Änderungen nicht mehr in der Datei(diese wurde in Rezepte umbenannt).

Exception in thread "main" javax.xml.bind.UnmarshalException: unerwartetes Element (URI:"", lokal:"Chefkoch"). Erwartete Elemente sind <{}Rezepte>
	at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallingContext.handleEvent(UnmarshallingContext.java:662)
	at com.sun.xml.bind.v2.runtime.unmarshaller.Loader.reportError(Loader.java:258)
	at com.sun.xml.bind.v2.runtime.unmarshaller.Loader.reportError(Loader.java:253)
	at com.sun.xml.bind.v2.runtime.unmarshaller.Loader.reportUnexpectedChildElement(Loader.java:120)
	at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallingContext$DefaultRootLoader.childElement(UnmarshallingContext.java:1063)
	at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallingContext._startElement(UnmarshallingContext.java:498)
	at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallingContext.startElement(UnmarshallingContext.java:480)
	at com.sun.xml.bind.v2.runtime.unmarshaller.SAXConnector.startElement(SAXConnector.java:150)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:501)
	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:400)
	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl$NSContentDriver.scanRootElementHook(XMLNSDocumentScannerImpl.java:626)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:3104)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl$PrologDriver.next(XMLDocumentScannerImpl.java:921)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:647)
	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(XMLNSDocumentScannerImpl.java:140)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737)
	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205)
	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522)
	at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal0(UnmarshallerImpl.java:218)
	at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal(UnmarshallerImpl.java:190)
	at javax.xml.bind.helpers.AbstractUnmarshallerImpl.unmarshal(AbstractUnmarshallerImpl.java:137)
	at javax.xml.bind.helpers.AbstractUnmarshallerImpl.unmarshal(AbstractUnmarshallerImpl.java:142)
	at javax.xml.bind.helpers.AbstractUnmarshallerImpl.unmarshal(AbstractUnmarshallerImpl.java:151)
	at javax.xml.bind.helpers.AbstractUnmarshallerImpl.unmarshal(AbstractUnmarshallerImpl.java:169)
	at generated.Aufgabe4b.main(Aufgabe4b.java:37)





Aufgabe5 - Diskutieren Sie, warum es sinnvoll ist Daten in Formaten wie XML oder JSON zu speichern. 
Stellen Sie außerdem die beiden Formate gegenüber und erläutern Sie kurz deren Vor- und Nachteile.

XML:

XML ist für die Beschreibung von Schnittstellen erstellt worden.
Es ist nicht auf JavaScript als Programmiersprache beschränkt
XML ist als Standart-Austauschprogramm weitverbreitet und wird deshalb sehr oft verwendet.

+ einfache Lesbarkeit von komplexen, verschachtelt übertragenen Daten. 
+ als Standard-Austauschformat etabliert
+ einfache Übertragung von Kommentaren und Metadaten  
+ vereinfachter Austausch mit Dritten

- komplexe Syntax – oft mit unnötigem „Ballast“ angereichert
- Struktur muss erst zerlegt werdenDaten in JavaScript-Objekte zu wandeln 

JSON:
Eine JSON-Datei besteht aus nur einem Objekt. 
Sie entspricht ganz genau XML, ist nur anders notiert und wegen der fehlenden schließenden Tags kürzer. 
Durch die kürzere Notation und die einfache Handhabung wirkt JSON einfacher als XML.
JSON kennt grundlegende Datentypen (float, int, string etc) und die Verschachtelungstypen Objekt und Array.

+ fast alle Vorteile von XML
+ kompakte, aufs Minimum reduzierte Syntax
+ das übertragene Datenvolumen geringer (gegenüber XML) 
+ reines JavaScript
+ keine Parsing-Vorgänge
+ unkomplizierte serverseitige Verarbeitung der JSON-Objekte.

- gewöhnungsbedürftige Syntax gesehen werden
- schlechtere Möglichkeiten, Metadaten und Kommentare zu integrieren
- weniger verbreitet als XML

XML und JSON werden dann verwendet, wenn HTML-Elemente mit neuen Daten befüllt werden sollen.
JSON ist unbekannter, jedoch vorteilhafter für den strukturierten Datenaustausch und ermöglicht
es, direkt JavaScript-Objekte auszutauschen. In XML ist dies nicht direkt möglich und wird durch 
Parsing gelöst.  






